/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

// sound.h -- private sound functions

#pragma once

#include "../client.h"
#include "shared/list.h"

#if USE_SNDDMA
#include "client/sound/dma.h"
#endif

#define MAX_SFX_SAMPLES     ((1 << 23) - 1)
#define S_OCCLUSION_GAIN            0.35f
#define S_OCCLUSION_LOWPASS_HZ      600.0f
#define S_OCCLUSION_LOWPASS_Q       0.707f
#define S_OCCLUSION_AL_GAINHF       0.08f
#define S_OCCLUSION_UPDATE_MS       50
#define S_OCCLUSION_CLEAR_MARGIN    0.1f
#define S_OCCLUSION_ATTACK_RATE     25.0f
#define S_OCCLUSION_RELEASE_RATE    8.0f
#define S_OCCLUSION_RADIUS_BASE     6.0f
#define S_OCCLUSION_RADIUS_SCALE    0.02f
#define S_OCCLUSION_RADIUS_MAX      24.0f
#define S_OCCLUSION_WINDOW_WEIGHT   0.25f
#define S_OCCLUSION_GLASS_WEIGHT    0.25f
#define S_OCCLUSION_GRATE_WEIGHT    0.3f
#define S_OCCLUSION_SOFT_WEIGHT     0.6f
#define S_OCCLUSION_WOOD_WEIGHT     0.75f
#define S_OCCLUSION_METAL_WEIGHT    0.85f
#define S_OCCLUSION_CONCRETE_WEIGHT 0.15f
#define S_OCCLUSION_DIFFRACTION_WEIGHT 0.4f
#define S_OCCLUSION_CURVE           0.75f
#define S_OCCLUSION_CUTOFF_REFERENCE_HZ 20000.0f
#define S_OCCLUSION_CUTOFF_MIN_HZ   400.0f
#define S_OCCLUSION_CUTOFF_CLEAR_HZ S_OCCLUSION_CUTOFF_REFERENCE_HZ
#define S_OCCLUSION_CUTOFF_DEFAULT_HZ (S_OCCLUSION_AL_GAINHF * S_OCCLUSION_CUTOFF_REFERENCE_HZ)
#define S_OCCLUSION_CUTOFF_GLASS_HZ 4000.0f
#define S_OCCLUSION_CUTOFF_GRATE_HZ S_OCCLUSION_CUTOFF_CLEAR_HZ
#define S_OCCLUSION_CUTOFF_SOFT_HZ  2000.0f
#define S_OCCLUSION_CUTOFF_WOOD_HZ  2000.0f
#define S_OCCLUSION_CUTOFF_CONCRETE_HZ 800.0f
#define S_OCCLUSION_CUTOFF_METAL_HZ 1500.0f

static inline float S_OcclusionCutoffToGainHF(float cutoff_hz)
{
    float cutoff = Q_clipf(cutoff_hz, S_OCCLUSION_CUTOFF_MIN_HZ, S_OCCLUSION_CUTOFF_REFERENCE_HZ);
    return cutoff / S_OCCLUSION_CUTOFF_REFERENCE_HZ;
}

typedef struct {
    int         length;
    int         loopstart;
    int         width;
    int         channels;
    int         size;
#if USE_OPENAL
    unsigned    bufnum;
#endif
#if USE_SNDDMA
    byte        data[1];        // variable sized
#endif
} sfxcache_t;

typedef struct {
    char        name[MAX_QPATH];
    char        *truename;
    sfxcache_t  *cache;
    unsigned    registration_sequence;
    int         error;
} sfx_t;

#define PS_FIRST(list)      LIST_FIRST(playsound_t, list, entry)
#define PS_TERM(ps, list)   LIST_TERM(ps, list, entry)

// a playsound_t will be generated by each call to S_StartSound,
// when the mixer reaches playsound->begin, the playsound will
// be assigned to a channel
typedef struct {
    list_t      entry;
    sfx_t       *sfx;
    float       volume;
    float       attenuation;
    int         entnum;
    int         entchannel;
    bool        fixed_origin;   // use origin field instead of entnum's origin
    vec3_t      origin;
    int         begin;          // begin on this sample
} playsound_t;

#if USE_SNDDMA
typedef struct {
    float   b0, b1, b2;
    float   a1, a2;
} occlusion_biquad_t;
#endif

typedef struct {
    sfx_t       *sfx;           // sfx number
    float       leftvol;        // 0.0-1.0 volume
    float       rightvol;       // 0.0-1.0 volume
    int         end;            // end time in global paintsamples
    int         pos;            // sample position in sfx
    int         entnum;         // to allow overriding a specific sound
    int         entchannel;     //
    vec3_t      origin;         // only use if fixed_origin is set
    vec_t       dist_mult;      // distance multiplier (attenuation/clipK)
    float       master_vol;     // 0.0-1.0 master volume
    bool        fixed_origin;   // use origin instead of fetching entnum's origin
    bool        autosound;      // from an entity->sound, cleared each frame
    bool        no_merge;       // bypass loop merging for this channel
    float       occlusion;      // 0.0-1.0 smoothed occlusion factor
    float       occlusion_target;
    int         occlusion_time;
    float       occlusion_mix;
    float       occlusion_cutoff;
    float       occlusion_cutoff_target;
#if USE_SNDDMA
    float       occlusion_z1[2];
    float       occlusion_z2[2];
    occlusion_biquad_t occlusion_biquad;
#endif
#if USE_OPENAL
    byte        fullvolume;
    unsigned    autoframe;
    unsigned    srcnum;
#endif
} channel_t;

typedef struct {
    char        *name;
    int         format;
    int         channels;
    int         rate;
    int         width;
    int         loopstart;
    int         samples;
    byte        *data;
} wavinfo_t;

/*
====================================================================

  SYSTEM SPECIFIC FUNCTIONS

====================================================================
*/

typedef struct {
    bool (*init)(void);
    void (*shutdown)(void);
    void (*update)(void);
    void (*activate)(void);
    void (*sound_info)(void);
    sfxcache_t *(*upload_sfx)(sfx_t *s);
    void (*delete_sfx)(sfx_t *s);
    void (*page_in_sfx)(sfx_t *s);
    const qboolean (*set_eax_effect_properties)(const sfx_eax_properties_t *eax_properties);
    bool (*raw_samples)(int samples, int rate, int width, int channels, const void *data, float volume);
    int (*need_raw_samples)(void);
    int (*have_raw_samples)(void);
    void (*drop_raw_samples)(void);
    void (*pause_raw_samples)(bool paused);
    int (*get_begin_ofs)(float timeofs);
    void (*play_channel)(channel_t *ch);
    void (*stop_channel)(channel_t *ch);
    void (*stop_all_sounds)(void);
    int (*get_sample_rate)(void);
    void (*end_registration)(void);
} sndapi_t;

#if USE_SNDDMA
extern const sndapi_t   snd_dma;
#endif

#if USE_OPENAL
extern const sndapi_t   snd_openal;
#endif

//====================================================================

typedef enum {
    SS_NOT,
#if USE_SNDDMA
    SS_DMA,
#endif
#if USE_OPENAL
    SS_OAL
#endif
} sndstarted_t;

extern sndstarted_t     s_started;
extern bool             s_active;
extern bool             s_supports_float;
extern const sndapi_t   *s_api;

extern channel_t    *s_channels;
extern int          s_numchannels, s_maxchannels;

extern int          s_paintedtime;
extern list_t       s_pendingplays;

extern wavinfo_t    s_info;

extern cvar_t       *s_volume;
extern cvar_t       *s_ambient;
#if USE_DEBUG
extern cvar_t       *s_show;
#endif
extern cvar_t       *s_underwater;
extern cvar_t       *s_underwater_gain_hf;
extern cvar_t       *s_num_channels;
extern cvar_t       *s_occlusion;
extern cvar_t       *s_occlusion_strength;

#define S_IsFullVolume(ch) \
    ((ch)->entnum == -1 || (ch)->entnum == listener_entnum || (ch)->dist_mult == 0)

#define S_IsUnderWater() \
    (cls.state == ca_active && (cl.frame.ps.rdflags | cl.predicted_rdflags) & RDF_UNDERWATER && s_underwater->integer)

#define S_Malloc(x)     Z_TagMalloc(x, TAG_SOUND)
#define S_CopyString(x) Z_TagCopyString(x, TAG_SOUND)

#define S_GetEntityLoopVolume(ent)      ((ent)->loop_volume ? (ent)->loop_volume : 1.0f)
#define S_GetEntityLoopStereoPan(ent)   !(cl.csr.extended && (ent)->renderfx & RF_NO_STEREO)

sfx_t *S_SfxForHandle(qhandle_t hSfx);
sfxcache_t *S_LoadSound(sfx_t *s);
channel_t *S_PickChannel(int entnum, int entchannel);
void S_IssuePlaysound(playsound_t *ps);
int S_BuildSoundList(int *sounds);
void S_SpatializeOrigin(const vec3_t origin, float master_vol, float dist_mult, float *left_vol, float *right_vol, bool stereo);
const qboolean S_SetEAXEnvironmentProperties(const sfx_eax_properties_t *properties);
float S_GetEntityLoopDistMult(const entity_state_t *ent);
float S_GetOcclusion(channel_t *ch, const vec3_t origin);
float S_SmoothOcclusion(channel_t *ch, float target);
float S_ComputeOcclusion(const vec3_t origin, float *cutoff_hz);
float S_MapOcclusion(float occlusion);
void S_ResetOcclusion(channel_t *ch);
