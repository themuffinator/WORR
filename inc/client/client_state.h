/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "shared/shared.h"
#include "shared/list.h"
#include "shared/game.h"

#include "common/bsp.h"
#include "common/cmodel.h"
#include "common/common.h"
#include "common/msg.h"
#include "common/net/chan.h"
#include "common/net/net.h"
#include "common/pmove.h"
#include "common/protocol.h"
#include "common/q2proto_shared.h"
#include "common/sizebuf.h"

#include "renderer/renderer.h"

#include "client/keys.h"
#include "client/client.h"

#include "q2proto/q2proto.h"

#if USE_ZLIB
#include <zlib.h>
#endif

//=============================================================================

typedef struct {
    entity_state_t     current;
    entity_state_t     prev;           // will always be valid, but might just be a copy of current

    vec3_t          mins, maxs;
    float           radius;             // from mid point

    int             serverframe;        // if not current, this ent isn't in the frame

    int             trailcount;         // for diminishing grenade trails
    vec3_t          lerp_origin;        // for trails (variable hz)

#if USE_FPS
    int             prev_frame;
    int             anim_start;

    int             event_frame;
#endif

    int             fly_stoptime;

    float           flashlightfrac;
    int             id;

// KEX
    int32_t         current_frame, last_frame, frame_servertime;
    int             stair_time;
    float           stair_height;
// KEX
} centity_t;

#define MAX_CLIENTWEAPONMODELS        256       // PGM -- upped from 16 to fit the chainfist vwep

typedef struct {
    char name[MAX_QPATH];
    qhandle_t skin;
    qhandle_t brightskin;
    char icon_name[MAX_QPATH];
    char model_name[MAX_QPATH];
    char skin_name[MAX_QPATH];
    char dogtag_name[MAX_QPATH];
    qhandle_t model;
    qhandle_t weaponmodel[MAX_CLIENTWEAPONMODELS];
} clientinfo_t;

typedef struct {
    unsigned    sent;    // time sent, for calculating pings
    unsigned    rcvd;    // time rcvd, for calculating pings
    unsigned    cmdNumber;    // current cmdNumber for this frame
} client_history_t;

typedef struct {
    bool            valid;

    int             number;
    int             delta;

    byte            areabits[MAX_MAP_AREA_BYTES];
    int             areabytes;

    player_state_t  ps;
    int             clientNum;

    int             numEntities;
    unsigned        firstEntity;
} server_frame_t;

// locally calculated frame flags for debug display
#define FF_SERVERDROP   BIT(4)
#define FF_BADFRAME     BIT(5)
#define FF_OLDFRAME     BIT(6)
#define FF_OLDENT       BIT(7)
#define FF_NODELTA      BIT(8)

// Time over which step climbing is smoothed
#define STEP_TIME       100

typedef struct {
    player_fog_t linear;
    player_heightfog_t height;
} cl_fog_params_t;

typedef struct {
    vec3_t      origin;
    float       radius;
    int         resolution;
    float       intensity;
    float       fade_start, fade_end;
    float       max_fade_dist;
    int         lightstyle;
    float       coneangle; // spot if non-zero
    vec3_t      conedirection;
    color_t     color;
} cl_shadow_light_t;

//
// the client_state_t structure is wiped completely at every
// server map change
//
typedef struct {
    int         timeoutcount;

    unsigned    lastTransmitTime;
    unsigned    lastTransmitCmdNumber;
    unsigned    lastTransmitCmdNumberReal;
    bool        sendPacketNow;

    usercmd_t    cmd;
    usercmd_t    cmds[CMD_BACKUP];    // each message will send several old cmds
    unsigned     cmdNumber;
    vec3_t       predicted_origins[CMD_BACKUP];    // for debug comparing against server
    client_history_t    history[CMD_BACKUP];
    unsigned    initialSeq;

    float       predicted_step;                // for stair up smoothing
    unsigned    predicted_step_time;

    vec3_t      predicted_origin;    // generated by CL_PredictMovement
    vec3_t      predicted_angles;
    vec3_t      predicted_velocity;
    vec4_t      predicted_screen_blend;
    refdef_flags_t predicted_rdflags;
    vec3_t      prediction_error;

    int8_t      current_viewheight; // current viewheight from client Pmove()
    int8_t      prev_viewheight;    // viewheight before last change
    int         viewheight_change_time; // time when a viewheight change was detected

    edict_t     *last_groundentity; // last groundentity reported by pmove
    cplane_t    last_groundplane; // last groundplane reported by pmove

    // rebuilt each valid frame
    centity_t       *solidEntities[MAX_PACKET_ENTITIES];
    int             numSolidEntities;

    entity_state_t  baselines[MAX_EDICTS];

    entity_state_t  entityStates[MAX_PARSE_ENTITIES];
    unsigned        numEntityStates;

    msgEsFlags_t    esFlags;
    msgPsFlags_t    psFlags;

    server_frame_t  frames[UPDATE_BACKUP];
    unsigned        frameflags;
    int             suppress_count;

    server_frame_t  frame;                // received from server
    server_frame_t  oldframe;
    int             servertime;
    int             serverdelta;

#if USE_FPS
    server_frame_t  keyframe;
    server_frame_t  oldkeyframe;
    int             keyservertime;
#endif

    size_t          dcs[BC_COUNT(MAX_CONFIGSTRINGS)];

    // the client maintains its own idea of view angles, which are
    // sent to the server each frame.  It is cleared to 0 upon entering each level.
    // the server sends a delta each frame which is added to the locally
    // tracked view angles to account for standing on rotating objects,
    // and teleport direction changes
    vec3_t      viewangles;

    // interpolated movement vector used for local prediction,
    // never sent to server, rebuilt each client frame
    vec2_t      localmove;

    // accumulated mouse forward/side movement, added to both
    // localmove and pending cmd, cleared each time cmd is finalized
    vec2_t      mousemove;

    // accumulated gamepad forward/side movement, added to both
    // localmove and pending cmd, cleared each time cmd is finalized
    vec2_t      gamepadmove;

    int         time;           // this is the time value that the client
                                // is rendering at.  always <= cl.servertime
    float       lerpfrac;       // between oldframe and frame

#if USE_FPS
    int         keytime;
    float       keylerpfrac;
#endif

    refdef_t    refdef;
    bool        menu_blur_active;
    clipRect_t  menu_blur_rect;
    float       fov_x;      // interpolated
    float       fov_y;      // derived from fov_x assuming 4/3 aspect ratio
    int         lightlevel;

    vec3_t      v_forward, v_right, v_up;    // set when refdef.angles is set

    bool        thirdPersonView;
    float       thirdPersonAlpha;

    // predicted values, used for smooth player entity movement in thirdperson view
    vec3_t      playerEntityOrigin;
    vec3_t      playerEntityAngles;

    //
    // transient data from server
    //
    cg_server_data_t cgame_data;

    //
    // server state information
    //
    int         serverstate;    // ss_* constants
    int         servercount;    // server identification for prespawns
    char        gamedir[MAX_QPATH];
    int         clientNum;            // never changed during gameplay, set by serverdata packet
    int         maxclients;
    int         max_stats;
    pmoveParams_t pmp;

    frametime_t frametime;
    float       frametime_inv;  // 1/frametime

    configstring_t  baseconfigstrings[MAX_CONFIGSTRINGS];
    configstring_t  configstrings[MAX_CONFIGSTRINGS];
    cs_remap_t      csr;
    q2proto_game_api_t game_api;

    char        mapname[MAX_QPATH]; // short format - q2dm1, etc

#if USE_AUTOREPLY
    unsigned    reply_time;
    unsigned    reply_delta;
#endif

    //
    // locally derived information from server state
    //
    bsp_t        *bsp;

    qhandle_t model_draw[MAX_MODELS];
    const mmodel_t *model_clip[MAX_MODELS];

    qhandle_t sound_precache[MAX_SOUNDS];
    qhandle_t image_precache[MAX_IMAGES];
    qhandle_t sfx_hit_marker;

    clientinfo_t    clientinfo[MAX_CLIENTS];
    clientinfo_t    baseclientinfo;

    char    weaponModels[MAX_CLIENTWEAPONMODELS][MAX_QPATH];
    int     numWeaponModels;
    
    bool    need_powerscreen_scale;

    int hit_marker_frame;
    unsigned hit_marker_time;
    int hit_marker_count;
    unsigned crosshair_hit_time;
    int crosshair_hit_damage;

    // data for view weapon
    struct {
        int32_t frame, last_frame;
        int32_t server_time;

        struct {
            qhandle_t   model;
            int         time;
            float       roll, scale;
            vec3_t      offset;
        } muzzle;
    } weapon;

    struct {
        cl_fog_params_t     start, end;
        int                 lerp_time, lerp_time_start;
    } fog;

    // shadow lights
    struct {
        int                 number;
        cl_shadow_light_t   light;
    } shadowdefs[MAX_SHADOW_LIGHTS];
} client_state_t;

/*
==================================================================

the client_static_t structure is persistent through an arbitrary number
of server connections

==================================================================
*/

// resend delay for challenge/connect packets
#define CONNECT_DELAY       3000u

#define CONNECT_INSTANT     CONNECT_DELAY
#define CONNECT_FAST        (CONNECT_DELAY - 1000u)

typedef enum {
    ca_uninitialized,
    ca_disconnected,    // not talking to a server
    ca_challenging,     // sending getchallenge packets to the server
    ca_connecting,      // sending connect packets to the server
    ca_connected,       // netchan_t established, waiting for svc_serverdata
    ca_loading,         // loading level data
    ca_precached,       // loaded level data, waiting for svc_frame
    ca_active,          // game views should be displayed
    ca_cinematic        // running a cinematic
} connstate_t;

typedef enum {
    // generic types
    DL_OTHER,
    DL_MAP,
    DL_MODEL,
#if USE_CURL
    // special types
    DL_LIST,
    DL_PAK
#endif
} dltype_t;

typedef enum {
    DL_FREE,
    DL_PENDING,
    DL_RUNNING,
    DL_DONE
} dlstate_t;

typedef struct {
    list_t      entry;
    dltype_t    type;
    dlstate_t   state;
    char        path[1];
} dlqueue_t;

typedef struct {
    int         framenum;
    unsigned    msglen;
    int64_t     filepos;
    byte        data[1];
} demosnap_t;

typedef struct {
    connstate_t state;
    keydest_t   key_dest;

    active_t    active;

    bool        ref_initialized;
    unsigned    disable_screen;

    int         userinfo_modified;
    cvar_t      *userinfo_updates[MAX_PACKET_USERINFOS];
// this is set each time a CVAR_USERINFO variable is changed
// so that the client knows to send it to the server

    unsigned    realtime;           // always increasing, no clamping, etc
    float       frametime;          // seconds since last video frame

    struct {
        unsigned    time;
        int         frames[4];
        int         fps[4];
        int         ping;
    } measure;

// connection information
    netadr_t    serverAddress;
    char        servername[MAX_OSPATH]; // name of server from original connect
    unsigned    connect_time;           // for connection retransmits
    int         connect_count;
    bool        passive;

#if USE_ZLIB
    z_stream    z;
#endif

    int         quakePort;          // a 16 bit value that allows quake servers
                                    // to work around address translating routers
    netchan_t   netchan;
    int         serverProtocol;     // in case we are doing some kind of version hack
    int         protocolVersion;    // minor version
    q2proto_clientcontext_t q2proto_ctx;

    int         challenge;          // from the server to use for connecting

#if USE_ICMP
    bool        errorReceived;      // got an ICMP error from server
#endif

#define RECENT_ADDR 4
#define RECENT_MASK (RECENT_ADDR - 1)

    netadr_t    recent_addr[RECENT_ADDR];
    unsigned    recent_head;

    string_entry_t  *stufftextwhitelist;

    struct {
        list_t      queue;              // queue of paths we need
        int         pending;            // number of non-finished entries in queue
        dlqueue_t   *current;           // path being downloaded
        int         percent;            // how much downloaded
        int64_t     position;           // how much downloaded (in bytes)
        qhandle_t   file;               // UDP file transfer from server
        char        temp[MAX_QPATH + 4];// account 4 bytes for .tmp suffix
        string_entry_t  *ignores;       // list of ignored paths
    } download;

// demo recording info must be here, so it isn't cleared on level change
    struct {
        qhandle_t   playback;
        qhandle_t   recording;
        unsigned    time_start;
        unsigned    time_frames;
        int         last_server_frame;  // number of server frame the last svc_frame was written
        int         frames_written;     // number of frames written to demo file
        int         frames_dropped;     // number of svc_frames that didn't fit
        int         others_dropped;     // number of misc svc_* messages that didn't fit
        int         frames_read;        // number of frames read from demo file
        int         last_snapshot;      // number of demo frame the last snapshot was saved
        int64_t     file_size;
        int64_t     file_offset;
        float       file_progress;
        sizebuf_t   buffer;
        demosnap_t  **snapshots;
        int         numsnapshots;
        bool        paused;
        bool        seeking;
        bool        eof;
        bool        compat;             // demomap compatibility mode
        msgEsFlags_t    esFlags;        // for snapshots/recording
        msgPsFlags_t    psFlags;

        // q2proto fields
        q2proto_server_info_t server_info;
        q2proto_servercontext_t q2proto_context;
#if USE_ZLIB
        z_stream        z;  // for compressing in demo snaps
        byte            *z_buffer;
        unsigned        z_buffer_size;
        q2protoio_deflate_args_t q2proto_deflate;
#endif
    } demo;

#if USE_CLIENT_GTV
    struct {
        connstate_t     state;

        netstream_t     stream;
        unsigned        msglen;

        player_packed_t     ps;
        entity_packed_t     entities[MAX_EDICTS];
        msgPsFlags_t        psFlags;
        msgEsFlags_t        esFlags;    // for writing
        msgPsFlags_t        psFlags;

        sizebuf_t       message;
    } gtv;
#endif
} client_static_t;

typedef struct {
    int type;
    vec3_t pos1;
    vec3_t pos2;
    vec3_t offset;
    vec3_t dir;
    int count;
    int color;
    int entity1;
    int entity2;
    int time;
} tent_params_t;

typedef struct {
    int entity;
    int weapon;
    bool silenced;
} mz_params_t;

#ifdef __cplusplus
}
#endif
